{
    "contents" : "# this file contains internal function, which are not intended to be used explicitly by users.\n\n# function to create dataList for analysis from the input data\ncreatDataList_One = function(data,N1,N2,plot=T){\n  name = deparse(substitute(data))\n  nSNP = dim(data)[1]\n  z = data$Alt_D\n  N = data$Alt_D+data$Ref_D\n  Nclust = 2\n  mixture = rep(NA,nSNP)\n  m = mean(z/N)\n  N1 = N1[N1!=0]\n  N2 = N2[N2!=0]\n  nSites = length(N2)\n  # N2 is the coverage for current chrom\n  N_cov = N2\n  # N1 is the coverage for the control\n  m0 = median(N1)\n  if (plot==T){\n    plotSites(data,name)\n    mtext(paste(\"m = \",as.character(round(mean(N_cov),1)),\", m0 = \",as.character(round(m0,1)),sep=\"\"),side=1,line=-1)\n  }\n  dataList = list(nSNP = nSNP,\n                  nSites = nSites,\n                  N_cov = N_cov,\n                  m = m,\n                  m0 = m0,\n                  z = z,\n                  N = N,\n                  mixture = mixture,\n                  Nclust = Nclust)\n  print(c(nSNP,nSites))\n  return(dataList)\n}\n\ncreatDataList_Two = function(data,N1,N2,plot=1){\n  name = deparse(substitute(data))\n  nSNP = dim(data)[1]\n  z = data$Alt_D\n  N = data$Alt_D+data$Ref_D\n  Nclust = 3\n  mixture = rep(NA,nSNP)\n  mixture[match(max(z/N),z/N)]=1\n  mixture[match(min(z/N),z/N)]=2\n  m = mean(z/N)\n  N1 = N1[N1!=0]\n  N2 = N2[N2!=0]\n  nSites = length(N2)\n  N_cov = N2\n  m0 = median(N1)\n  \n  if (plot==1){\n    plotSites(data,name)\n    mtext(paste(\"m = \",as.character(round(mean(N_cov),1)),\", m0 = \",as.character(round(m0,1)),sep=\"\"),side=1,line=-1)\n  }\n  \n  dataList = list(nSNP = nSNP,\n                  nSites = nSites,\n                  N_cov = N_cov,\n                  m0 = m0,\n                  z = z,\n                  N = N,\n                  m = m,\n                  mixture = mixture,\n                  Nclust = Nclust)\n  #print(c(nSNP,nSites))\n  return(dataList)\n}\n\ncreatDataList_Four = function(data,N1,N2,plot=1){\n  name = deparse(substitute(data))\n  nSNP = dim(data)[1]\n  z = data$Alt_D\n  N = data$Alt_D+data$Ref_D\n  Nclust = 5\n  m = mean(z/N)\n  BAF = z/N\n  mixture = rep(NA,nSNP)\n  mixture[match(sort(BAF[BAF<m],decreasing=T)[5],BAF)]=2\n  mixture[match(sort(BAF[BAF>m],decreasing=F)[5],BAF)]=1  \n  N1 = N1[N1!=0]\n  N2 = N2[N2!=0]\n  nSites = length(N2)\n  N_cov = N2\n  m0 = median(N1)\n  \n  if (plot==1){\n    plotSites(data,name)\n    mtext(paste(\"m = \",as.character(round(mean(N_cov),1)),\", m0 = \",as.character(round(m0,1)),sep=\"\"),side=1,line=-1)\n  }\n  dataList = list(nSNP = nSNP,\n                  nSites = nSites,\n                  N_cov = N_cov,\n                  m0 = m0,\n                  z = z,\n                  N = N,\n                  m = m,\n                  mixture = mixture,\n                  Nclust = Nclust)\n  print(c(nSNP,nSites))\n  print(c(m0=m0,m=mean(N_cov)))\n  return(dataList)\n}\n\n# get the posterior median of each theta from the runModels output\ntheta_median = function(data){\n  start=match(\"theta[1]\",colnames(data))\n  end = dim(data)[2]\n  theta = data[,start:end]\n  theta_m = apply(theta,2,median)\n  return(theta_m)\n}\n\n# plot the AAF along chromosome given the data\nplotSites = function(dat,name){\n  x = dat$position\n  y = dat$Alt_D/(dat$Alt_D+dat$Ref_D)\n  m = mean(y)\n  plot(x,y,pch=20,col=\"blue\",ylim=c(0,1),xlab=paste(dat[1,1],\"position\"),ylab=\"Alternative Allele Frequency\",main=name)\n  abline(h=m,lwd=3,lty=2)\n}\n\n# calculate the BIC value for one mixture model\ncalculateBIC1 = function(post,theta,datalist){\n  N = datalist$N\n  z = datalist$z\n  mu = post[\"mu\"]\n  kappa = post[\"kappa\"]\n  a = mu*kappa\n  b = (1-mu)*kappa\n  p1 = post[\"p1\"]\n  p2 = post[\"p2\"]\n  \n  log.aaf = 0\n  for (i in 1:length(theta)){\n    p_theta = p1*dbeta(theta[i],a,b)+p2*dbeta(theta[i],1,1)\n    log.like.aaf = log(p_theta*dbinom(z[i],N[i],prob=theta[i]))\n    log.aaf = log.aaf+log.like.aaf\n  }\n  # print(unname(log.aaf))\n  # the log likelihood for coverage\n  N_cov = datalist$N_cov\n  r_cov = post[\"r_cov\"]\n  p_cov = post[\"p_cov\"]\n  log.cov = 0\n  for (i in 1:length(N_cov)){\n    log.like.cov = log(dnbinom(N_cov[i],size=r_cov,prob=p_cov))\n    log.cov = log.cov + log.like.cov\n  }\n  # print(log.cov)\n  log.sum = log.aaf+log.cov\n  deviance = -2*log.sum\n  \n  # calculate BIC\n  # datapoint\n  datapoint = datalist$nSites + sum(datalist$N)\n  BIC = 3*log(datapoint)+deviance\n  return(BIC)\n}\n\n# calculate the BIC value for two mixture model\ncalculateBIC2 = function(post,theta,datalist){\n  N = datalist$N\n  z = datalist$z\n  a1 = post[\"mu[1]\"]*post[\"kappa\"]\n  b1 = (1-post[\"mu[1]\"])*post[\"kappa\"]\n  a2 = post[\"mu[2]\"]*post[\"kappa\"]\n  b2 = (1-post[\"mu[2]\"])*post[\"kappa\"]\n  p1 = post[\"p1\"]\n  p2 = post[\"p2\"]\n  p3 = post[\"p3\"]\n  \n  log.aaf = 0\n  for (i in 1:length(theta)){\n    p_theta = p1*dbeta(theta[i],a1,b1)+p2*dbeta(theta[i],a2,b2)+p3*dbeta(theta[i],1,1)\n    log.like.aaf = log(p_theta*dbinom(z[i],N[i],prob=theta[i]))\n    log.aaf = log.aaf+log.like.aaf\n  }\n  # print(unname(log.aaf))\n  # the log likelihood for coverage\n  N_cov = datalist$N_cov\n  r_cov = post[\"r_cov\"]\n  p_cov = post[\"p_cov\"]\n  log.cov = 0\n  for (i in 1:length(N_cov)){\n    log.like.cov = log(dnbinom(N_cov[i],size=r_cov,prob=p_cov))\n    log.cov = log.cov + log.like.cov\n  }\n  # print(log.cov)\n  log.sum = log.aaf+log.cov\n  deviance = -2*log.sum\n  \n  # calculate BIC\n  # datapoint\n  datapoint = datalist$nSites + sum(datalist$N)\n  BIC = 5*log(datapoint)+deviance\n  return(BIC)\n}\n\n# calculate the BIC value for four mixture model\ncalculateBIC4 = function(post,theta,datalist){\n  N = datalist$N\n  z = datalist$z\n  a1 = post[\"mu[1]\"]*post[\"kappa\"]\n  b1 = (1-post[\"mu[1]\"])*post[\"kappa\"]\n  a2 = post[\"mu[2]\"]*post[\"kappa\"]\n  b2 = (1-post[\"mu[2]\"])*post[\"kappa\"]\n  a3 = post[\"mu[3]\"]*post[\"kappa\"]\n  b3 = (1-post[\"mu[3]\"])*post[\"kappa\"]\n  a4 = post[\"mu[4]\"]*post[\"kappa\"]\n  b4 = (1-post[\"mu[4]\"])*post[\"kappa\"]\n  p1 = post[\"p1\"]\n  p2 = post[\"p2\"]\n  p3 = post[\"p3\"]\n  p4 = post[\"p4\"]\n  p5 = post[\"p5\"]\n  \n  log.aaf = 0\n  for (i in 1:length(theta)){\n    p_theta = p1*dbeta(theta[i],a1,b1)+p2*dbeta(theta[i],a2,b2)+p3*dbeta(theta[i],a3,b3)+p4*dbeta(theta[i],a4,b4)+p5*dbeta(theta[i],1,1)\n    log.like.aaf = log(p_theta*dbinom(z[i],N[i],prob=theta[i]))\n    log.aaf = log.aaf+log.like.aaf\n  }\n  # print(unname(log.aaf))\n  # the log likelihood for coverage\n  N_cov = datalist$N_cov\n  r_cov = post[\"r_cov\"]\n  p_cov = post[\"p_cov\"]\n  log.cov = 0\n  for (i in 1:length(N_cov)){\n    log.like.cov = log(dnbinom(N_cov[i],size=r_cov,prob=p_cov))\n    log.cov = log.cov + log.like.cov\n  }\n  # print(log.cov)\n  log.sum = log.aaf+log.cov\n  deviance = -2*log.sum\n  \n  # calculate BIC\n  # datapoint\n  datapoint = datalist$nSites + sum(datalist$N)\n  BIC = 7*log(datapoint)+deviance\n  return(BIC)\n}\n\n# get the HDI of the posterior distribution from MCMC chain at a given interval\nHDIofMCMC = function( sampleVec , credMass=0.95 ) {\n  # Computes highest density interval from a sample of representative values,\n  #   estimated as shortest credible interval.\n  # Arguments:\n  #   sampleVec\n  #     is a vector of representative values from a probability distribution.\n  #   credMass\n  #     is a scalar between 0 and 1, indicating the mass within the credible\n  #     interval that is to be estimated.\n  # Value:\n  #   HDIlim is a vector containing the limits of the HDI\n  sortedPts = sort( sampleVec )\n  ciIdxInc = floor( credMass * length( sortedPts ) )\n  nCIs = length( sortedPts ) - ciIdxInc\n  ciWidth = rep( 0 , nCIs )\n  for ( i in 1:nCIs ) {\n    ciWidth[ i ] = sortedPts[ i + ciIdxInc ] - sortedPts[ i ]\n  }\n  HDImin = sortedPts[ which.min( ciWidth ) ]\n  HDImax = sortedPts[ which.min( ciWidth ) + ciIdxInc ]\n  HDIlim = c( HDImin , HDImax )\n  return( HDIlim )\n}\n",
    "created" : 1438801067147.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2548245829",
    "id" : "63CADA90",
    "lastKnownWriteTime" : 1438801223,
    "path" : "~/Project/Aneuploidy/MADSEQ/R/Private.R",
    "project_path" : "R/Private.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}