{
    "contents" : "#-----------------1. Functions to prepare dataList for the analysis----------------\n\n# 1. function to check if the data is valid for further analysis\n\n# data considered as valid if all the sites:\n# 1). come from the same chromosome 2). all of them are biallelic sites (with both ref/alt alleles) 3). it has the four fields: chr, position, Ref_D,Alt_D\n#' Check if the data is valid for MAD-SEQ analysis\n#' \n#' Take in the data frame and check if it meets all the requirements\n#' @param data The data frame to be used for analysis\n#' @return Ture or error code indicate why the data fails the requirements\n#' @export\nvalidateData = function(data){\n  # 1. check four required columns\n  # check if there is chr column\n  if(is.na(match(\"chr\",colnames(data)))){\n    stop(\"Error: No field named as 'chr', please check your data\") \n  }\n  # check if there is position column\n  if(is.na(match(\"position\",colnames(data)))){\n    stop(\"Error: No field named as 'position', please check your data\") \n  }\n  # check if there is Ref_D column\n  if(is.na(match(\"Ref_D\",colnames(data)))){\n    stop(\"Error: No field named as 'Ref_D', please check your data\") \n  }\n  # check if there is Alt_D column\n  if(is.na(match(\"Alt_D\",colnames(data)))){\n    stop(\"Error: No field named as 'Alt_D', please check your data\") \n  }\n  \n  # 2. check if all the sites come from the same chromosome\n  if(length(table(data$chr))>1) {\n    stop(\"there are more than one chromosomes, please check your data\")\n  }\n  \n  # 3. check if all the sites are biallelic sites\n  for (i in 1:nrow(data)){\n    if(data[i,\"Alt_D\"]/(data[i,\"Alt_D\"]+data[i,\"Ref_D\"])==0|data[i,\"Alt_D\"]/(data[i,\"Alt_D\"]+data[i,\"Ref_D\"])==1){\n      stop(paste(\"the site in the\",i,\"row is not biallelic, please check your data\"))\n    }\n  }  \n  return(TRUE)\n}\n\n#--------------------2. Functions to run MCMC on the data----------------\n#  1. function to run the One Mixture Model\n#' Use the one mixture model to fit the data\n#' \n#' Take in the heterozygous sites and coverage information, use one mixture model to fit the data\n#' @param data dataframe: include at least four fields: chr (chromosome), position (position), Ref_D (read depth for reference allele) and Alt_D (read depth for alternative allele). Check if your input dataframe meets all the requirements by function validateData(data) \n#' @param data_coverage numeric vector: the coverage information for all the sites on this chromosome (sites with all genotypes)\n#' @param control_coverage numeric vector: control coverage information: it can be the average coverage of the whole genome. Or the mean of the normalized coverage.\n#' @param adapt integer: the number of steps to \"tune\" the samplers. (default=10000)\n#' @param burnin integer: the number of steps to \"burn-in\" the samplers. (default=10000)\n#' @param nChain integer: the number of chains to run. (default=2)\n#' @param nStep integer: total number of steps in chains to save (default=20000)\n#' @param thinSteps interger: save data every thinSteps (default=2)\n#' @param checkConvergence Boolean: check if the posterior estimation is converged by gelman and rubin diagnostic. Only available when you have more than 2 chains. (default=FALSE) If chains are not converged, then you should increase adapt and burnin steps.\n#' @param plot Boolean: plot the alternative allele frequencies along the chromosome. (default=TRUE)\n#' @return A MadSeqOutput object with two components\n#' @return \\code{posterior} the posterior output from MCMC \n#' @return \\code{BIC} the BIC value for this model\n#' @import rjags\n#' @import coda\n#' @export\n#' @seealso \\code{\\link{runModelMonosomy}} \\code{\\link{runModelTrisomy}} \\code{\\link{runModelFour}} \\code{\\link{validateData}}\nrunModelOne = function(data,data_coverage,control_coverage,adapt=10000,burnin=10000,nChain=2,nStep=20000,thinSteps=2,checkConvergence=FALSE,plot=TRUE){\n  # basic settings\n  adaptSteps = adapt              # Number of steps to \"tune\" the samplers.\n  burnInSteps = burnin            # Number of steps to \"burn-in\" the samplers.\n  nChains = nChain               # Number of chains to run.\n  numSavedSteps=nStep          # Total number of steps in chains to save.\n  thinSteps=thinSteps                  # Number of steps to \"thin\" (1=keep every step).\n  nIter = ceiling( ( numSavedSteps * thinSteps ) / nChains )\n  parameters_one = c(\"kappa\",\"p_cov\",\"r_cov\",\"theta\",\"mu\",\"m_cov\")\n  record_one = c(\"kappa\",\"p_cov\",\"r_cov\",\"mu\",\"m_cov\")\n  \n  # generate dataList for the MCMC\n  dataList = creatDataList_One(data=data,N1=control_coverage,N2=data_coverage,plot=plot)\n  \n  # run model\n  fpath = system.file(\"rjags\",\"OneMix.txt\",package=\"MADSEQ\")\n  jagsModel_one = jags.model( fpath, data=dataList ,n.chains=nChains , n.adapt=adaptSteps )\n  update( jagsModel_one , n.iter=burnInSteps )\n  codaSamples_one = coda.samples( jagsModel_one , variable.names=parameters_one , n.iter=nIter , thin=thinSteps )\n  mat = as.matrix(codaSamples_one)\n  theta = theta_median(mat)\n  mat = mat[,record_one]\n  \n  if(checkConvergence==TRUE){\n    diag = gelman.diag(codaSamples_one,multivariate = FALSE)\n    upper = max(diag$psrf[,2],na.rm=TRUE)\n    if (upper<=2) print(\"converged!\")\n    else if (upper > 2 & upper <= 10) print(\"not fulled converged\")\n    else if (upper>10) print(\"not converge\")\n  }\n  post = apply(mat,2,median)\n  BIC = calculateBIC1(post,theta,dataList)\n  names(BIC) = \"BIC_one\"\n  res = list(posterior=mat,BIC=BIC)\n  res = as.MadSeqOutput(res)\n  return(res)\n}\n\n\n# 2. function to run Monosomy Mixture Model\n#' Use the two mixture monosomy model to fit the data\n#' \n#' Take in the heterozygous sites and coverage information, use two mixture monosomy model to fit the data\n#' @param data dataframe: include at least four fields: chr (chromosome), position (position), Ref_D (read depth for reference allele) and Alt_D (read depth for alternative allele). Check if your input dataframe meets all the requirements by function validateData(data) \n#' @param data_coverage numeric vector: the coverage information for all the sites on this chromosome (sites with all genotypes)\n#' @param control_coverage numeric vector: control coverage information: it can be the average coverage of the whole genome. Or the mean of the normalized coverage.\n#' @param adapt integer: the number of steps to \"tune\" the samplers. (default=10000)\n#' @param burnin integer: the number of steps to \"burn-in\" the samplers. (default=10000)\n#' @param nChain integer: the number of chains to run. (default=2)\n#' @param nStep integer: total number of steps in chains to save (default=20000)\n#' @param thinSteps interger: save data every thinSteps (default=2)\n#' @param checkConvergence Boolean: check if the posterior estimation is converged. Only available when you have more than 2 chains. (default=FALSE)\n#' @param plot Boolean: plot the alternative allele frequencies along the chromosome. (default=TRUE)\n#' @return A MadSeqOutput object with two components\n#' @return \\code{posterior} the posterior output from MCMC \n#' @return \\code{BIC} the BIC value for this model\n#' @import rjags\n#' @import coda\n#' @export\n#' @seealso \\code{\\link{runModelOne}} \\code{\\link{runModelTrisomy}} \\code{\\link{runModelFour}} \\code{\\link{validateData}}\nrunModelMonosomy = function(data,data_coverage,control_coverage,adapt=10000,burnin=10000,nChain=2,nStep=20000,thinSteps=2,checkConvergence=FALSE,plot=TRUE){\n  # basic settings\n  adaptSteps = adapt              # Number of steps to \"tune\" the samplers.\n  burnInSteps = burnin            # Number of steps to \"burn-in\" the samplers.\n  nChains = nChain               # Number of chains to run.\n  numSavedSteps=nStep          # Total number of steps in chains to save.\n  thinSteps=thinSteps                  # Number of steps to \"thin\" (1=keep every step).\n  nIter = ceiling( ( numSavedSteps * thinSteps ) / nChains )\n  parameters_two = c(\"p_cov\",\"m_cov\",\"r_cov\",\"mu\",\"kappa\",\"d1\",\"d2\",\"f\",\"theta\")\n  record_two = c(\"f\",\"kappa\",\"mu[1]\",\"mu[2]\",\"d1\",\"d2\",\"p_cov\",\"r_cov\",\"m_cov\")\n  \n  # generate dataList for the MCMC\n  dataList = creatDataList_Two(data=data,N1=control_coverage,N2=data_coverage,plot=plot)\n  \n  # run model\n  fpath = system.file(\"rjags\",\"TwoMixMonosomy.txt\",package=\"MADSEQ\")\n  jagsModel3 = jags.model( fpath , data=dataList , n.chains=nChains , n.adapt=adaptSteps )\n  update( jagsModel3 , n.iter=burnInSteps )\n  codaSamples3 = coda.samples( jagsModel3 , variable.names=parameters_two , n.iter=nIter , thin=thinSteps )\n  mat = as.matrix(codaSamples3)\n  theta = theta_median(mat)\n  mat = mat[,record_two]\n  \n  if(checkConvergence==TRUE){\n    diag = gelman.diag(codaSamples3,multivariate = FALSE)\n    upper = max(diag$psrf[,2],na.rm=TRUE)\n    if (upper<=2) print(\"converged!\")\n    else if (upper > 2 & upper <= 10) print(\"not fulled converged\")\n    else if (upper>10) print(\"not converge\")\n  }\n  \n  post = apply(mat,2,median)\n  BIC = calculateBIC2(post,theta,dataList)\n  names(BIC) = \"BIC_monosomy\"\n  res = list(posterior=mat,BIC=BIC)\n  res = as.MadSeqOutput(res)\n  return(res)\n}\n\n\n# 3. function to run Trisomy Two Mixture Model\n#' Use the two mixture trisomy model to fit the data\n#' \n#' Take in the heterozygous sites and coverage information, use two mixture trisomy model to fit the data\n#' @param data dataframe: include at least four fields: chr (chromosome), position (position), Ref_D (read depth for reference allele) and Alt_D (read depth for alternative allele). Check if your input dataframe meets all the requirements by function validateData(data) \n#' @param data_coverage numeric vector: the coverage information for all the sites on this chromosome (sites with all genotypes)\n#' @param control_coverage numeric vector: control coverage information: it can be the average coverage of the whole genome. Or the mean of the normalized coverage.\n#' @param adapt integer: the number of steps to \"tune\" the samplers. (default=10000)\n#' @param burnin integer: the number of steps to \"burn-in\" the samplers. (default=10000)\n#' @param nChain integer: the number of chains to run. (default=2)\n#' @param nStep integer: total number of steps in chains to save (default=20000)\n#' @param thinSteps interger: save data every thinSteps (default=2)\n#' @param checkConvergence Boolean: check if the posterior estimation is converged. Only available when you have more than 2 chains. (default=FALSE)\n#' @param plot Boolean: plot the alternative allele frequencies along the chromosome. (default=TRUE)\n#' @return A MadSeqOutput object with two components\n#' @return \\code{posterior} the posterior output from MCMC \n#' @return \\code{BIC} the BIC value for this model\n#' @import rjags\n#' @import coda\n#' @export\n#' @seealso \\code{\\link{runModelOne}} \\code{\\link{runModelMonosomy}} \\code{\\link{runModelFour}} \\code{\\link{validateData}}\nrunModelTrisomy = function(data,data_coverage,control_coverage,adapt=10000,burnin=10000,nChain=2,nStep=20000,thinSteps=2,checkConvergence=FALSE,plot=TRUE){\n  # basic settings\n  adaptSteps = adapt              # Number of steps to \"tune\" the samplers.\n  burnInSteps = burnin            # Number of steps to \"burn-in\" the samplers.\n  nChains = nChain               # Number of chains to run.\n  numSavedSteps=nStep          # Total number of steps in chains to save.\n  thinSteps=thinSteps                  # Number of steps to \"thin\" (1=keep every step).\n  nIter = ceiling( ( numSavedSteps * thinSteps ) / nChains )\n  parameters_two = c(\"p_cov\",\"m_cov\",\"r_cov\",\"mu\",\"kappa\",\"d1\",\"d2\",\"f\",\"theta\")\n  record_two = c(\"f\",\"kappa\",\"mu[1]\",\"mu[2]\",\"d1\",\"d2\",\"p_cov\",\"r_cov\",\"m_cov\")\n  \n  # generate dataList for the MCMC\n  dataList = creatDataList_Two(data=data,N1=control_coverage,N2=data_coverage,plot=plot)\n  \n  # run model\n  fpath = system.file(\"rjags\",\"TwoMixTrisomy.txt\",package=\"MADSEQ\")\n  jagsModel2 = jags.model(fpath , data=dataList , n.chains=nChains , n.adapt=adaptSteps )\n  update( jagsModel2 , n.iter=burnInSteps )\n  codaSamples2 = coda.samples( jagsModel2 , variable.names=parameters_two , n.iter=nIter , thin=thinSteps )\n  mat = as.matrix(codaSamples2)\n  theta = theta_median(mat)\n  mat = mat[,record_two]\n  \n  if(checkConvergence==TRUE){\n    diag = gelman.diag(codaSamples2,multivariate = FALSE)\n    upper = max(diag$psrf[,2],na.rm=TRUE)\n    if (upper<=2) print(\"converged!\")\n    else if (upper > 2 & upper <= 10) print(\"not fulled converged\")\n    else if (upper>10) print(\"not converge\")\n  }\n  \n  post = apply(mat,2,median)\n  BIC = calculateBIC2(post,theta,dataList)\n  names(BIC) = \"BIC_trisomy\"\n  res = list(posterior=mat,BIC=BIC)\n  res = as.MadSeqOutput(res)\n  return(res)\n}\n\n\n# 4. function to run Four Mixture Model\n#' Use the four mixture model to fit the data\n#' \n#' Take in the heterozygous sites and coverage information, use four mixture model to fit the data\n#' @param data dataframe: include at least four fields: chr (chromosome), position (position), Ref_D (read depth for reference allele) and Alt_D (read depth for alternative allele). Check if your input dataframe meets all the requirements by function validateData(data) \n#' @param data_coverage numeric vector: the coverage information for all the sites on this chromosome (sites with all genotypes)\n#' @param control_coverage numeric vector: control coverage information: it can be the average coverage of the whole genome. Or the mean of the normalized coverage.\n#' @param adapt integer: the number of steps to \"tune\" the samplers. (default=10000)\n#' @param burnin integer: the number of steps to \"burn-in\" the samplers. (default=10000)\n#' @param nChain integer: the number of chains to run. (default=2)\n#' @param nStep integer: total number of steps in chains to save (default=20000)\n#' @param thinSteps interger: save data every thinSteps (default=2)\n#' @param checkConvergence Boolean: check if the posterior estimation is converged. Only available when you have more than 2 chains. (default=FALSE)\n#' @param plot Boolean: plot the alternative allele frequencies along the chromosome. (default=TRUE)\n#' @return A MadSeqOutput object with two components\n#' @return \\code{posterior} the posterior output from MCMC \n#' @return \\code{BIC} the BIC value for this model\n#' @import rjags\n#' @import coda\n#' @export\n#' @seealso \\code{\\link{runModelOne}} \\code{\\link{runModelMonosomy}} \\code{\\link{runModelTrisomy}} \\code{\\link{validateData}}\nrunModelFour = function(data,data_coverage,control_coverage,adapt=10000,burnin=10000,nChain=2,nStep=20000,thinSteps=2,checkConvergence=FALSE,plot=TRUE){\n  # basic settings\n  adaptSteps = adapt              # Number of steps to \"tune\" the samplers.\n  burnInSteps = burnin            # Number of steps to \"burn-in\" the samplers.\n  nChains = nChain               # Number of chains to run.\n  numSavedSteps=nStep          # Total number of steps in chains to save.\n  thinSteps=thinSteps                  # Number of steps to \"thin\" (1=keep every step).\n  nIter = ceiling( ( numSavedSteps * thinSteps ) / nChains )\n  parameters_four = c(\"p_cov\",\"m_cov\",\"r_cov\",\"mu\",\"kappa\",\"d1\",\"d2\",\"d3\",\"d4\",\"p\",\"f\",\"theta\")\n  record_four = c(\"f\",\"p[1]\",\"p[2]\",\"p[3]\",\"p[4]\",\"p[5]\",\"kappa\",\"mu[1]\",\"mu[2]\",\"mu[3]\",\"mu[4]\",\"d1\",\"d2\",\"d3\",\"d4\",\"p_cov\",\"r_cov\",\"m_cov\")\n  \n  # generate dataList for the MCMC\n  dataList = creatDataList_Four(data=data,N1=control_coverage,N2=data_coverage,plot=plot)\n  \n  # run model\n  fpath = system.file(\"rjags\",\"FourMix.txt\",package=\"MADSEQ\")\n  jagsModel_four = jags.model( fpath , data=dataList ,n.chains=nChains , n.adapt=adaptSteps ) \n  update(jagsModel_four , n.iter=burnInSteps)\n  codaSamples_four = coda.samples( jagsModel_four , variable.names=parameters_four ,  n.iter=nIter , thin=thinSteps )\n  mat = as.matrix(codaSamples_four)\n  theta = theta_median(mat)\n  mat = mat[,record_four]\n  \n  if(checkConvergence==TRUE){\n    diag = gelman.diag(codaSamples_four,multivariate = FALSE)\n    upper = max(diag$psrf[,2],na.rm=TRUE)\n    if (upper<=2) print(\"converged!\")\n    else if (upper > 2 & upper <= 10) print(\"not fulled converged\")\n    else if (upper>10) print(\"not converge\")\n  }\n  \n  post = apply(mat,2,median)\n  BIC = calculateBIC4(post,theta,dataList)\n  names(BIC) = \"BIC_four\"\n  res = list(posterior=mat,BIC=BIC)\n  res = as.MadSeqOutput(res)\n  return(res)\n}\n\n\n# 5. function to compare models, and select the best model\n#' select the best MADSEQ model for input data\n#' \n#' compare multiple MadSeq models using BIC. Print out the order of preference\n#' @param object1 MadSeqOutput object, which is produced by one of the runModel functions\n#' @param object2 MadSeqOutput object\n#' @param ... MadSeqOutput object\n#' @return a character indicating which is the best model\n#' @details the function compare different models using BIC, the model with lowest BIC value is the best model. The deltaBIC between models indicate the evidence against higher BIC\n#' deltaBIC ~ [0,2]: Not worth more than a bare mention                                                                                                                                                    \n#' deltaBIC ~ [2,6]: Positive\n#' deltaBIC ~ [6,10]: Strong\n#' deltaBIC >10: Very Strong\n#' @export\nmodelSelection = function(object1,object2,...){\n  data = list(object1,object2,...)\n  n_items = length(data)\n  type = NULL\n  BIC = NULL\n  for (i in 1:n_items){\n    tmp = data[[i]]\n    tmp_BIC = tmp$BIC\n    tmp_type = substr(names(tmp_BIC),5,nchar(names(tmp_BIC)))\n    BIC = c(BIC,tmp_BIC)\n    type = c(type,tmp_type)\n  }\n  names(BIC) = type\n  BIC = sort(BIC,decreasing = F)\n  cat(\"Order of the preference of models\\n\")\n  print(BIC)\n  best = min(BIC)\n  best_name = names(BIC)[match(min(BIC),BIC)]\n  names(best) = best_name\n  cat(\"\\nBest Model\\n\")\n  print(best)\n  return(names(best))\n}\n\n# 6. function to return deltaBIC for different models\n#' compare different MADSEQ models, and calculate deltaBIC between models.\n#' \n#' compare multiple MadSeq models using BIC. Print out the deltaBIC between current model and the best model\n#' @param object1 MadSeqOutput object, which is produced by one of the runModel functions\n#' @param object2 MadSeqOutput object\n#' @param ... MadSeqOutput object\n#' @return a named numeric vector indicating the deltaBIC between current model and the best model \n#' @details the function calculated deltaBIC between the best model and given models. The model with lowest BIC value is the best model. The deltaBIC between models indicate the evidence against higher BIC\n#' deltaBIC ~ [0,2]: Not worth more than a bare mention                                                                                                                                                    \n#' deltaBIC ~ [2,6]: Positive\n#' deltaBIC ~ [6,10]: Strong\n#' deltaBIC >10: Very Strong\n#' @export\nmodelComparison = function(object1,object2,...){\n  data = list(object1,object2,...)\n  n_items = length(data)\n  type = NULL\n  BIC = NULL\n  for (i in 1:n_items){\n    tmp = data[[i]]\n    tmp_BIC = tmp$BIC\n    tmp_type = substr(names(tmp_BIC),5,nchar(names(tmp_BIC)))\n    BIC = c(BIC,tmp_BIC)\n    type = c(type,tmp_type)\n  }\n  names(BIC) = type\n  BIC = sort(BIC,decreasing = F)\n  \n  deltaBIC = BIC-min(BIC)\n  return(deltaBIC)\n}\n\n#-------------------------3. Function to process output from Model-------------------\n# 1. plot the density plots for the posterior distribution\n#' Plot the posterior density estimates from runModel output\n#' \n#' Display density plots of the posterior estimates of choosen variables, the density is produced by density function.\n#' @param object A MadSeqOutput object, which is produced by one of the runModel functions\n#' @param variable A character vector indicates the posterior density of which variable to be plot. (default is plot all the variables)\n#' @export\nplotPosterior = function(object,variable=\"all\"){\n  data = as.data.frame(object$posterior)\n  n_total = dim(data)[2]\n  all_name = names(data)\n  \n  # if want to check all the posterior distribution\n  if(paste(variable,collapse = \"\")==\"all\"){\n    par(mfrow=c(3,2))\n    par(mar=c(2.5,4,3,2))\n    for (i in all_name){\n      tmp_dat = data[,i]\n      if (min(tmp_dat)==max(tmp_dat)){\n        hist(tmp_dat,prob=TRUE,main=paste(\"posterior density of\",i),xlab=\"\")\n      }\n      else{\n        plot(density(tmp_dat),xlab=\"\",lwd=2,col=\"blue\",main=paste(\"posterior density of\",i))\n      }\n    }\n  }\n  \n  # only want to check some of the posterior distribution\n  else{\n    n_plot = length(variable)\n    if (n_plot>=6) par(mfrow=c(3,2))\n    else if (n_plot>1) par(mfrow=c(ceiling(n_plot/2),2))\n    else if (n_plot==1) par(mfrow=c(1,1))\n    par(mar=c(2.5,4,3,2))\n    for (i in variable){\n      tmp_dat = data[,i]\n      if (min(tmp_dat)==max(tmp_dat)){\n        hist(tmp_dat,prob=TRUE,main=paste(\"posterior density of\",i),xlab=\"\")\n      }\n      else{\n        plot(density(tmp_dat),xlab=\"\",lwd=2,col=\"blue\",main=paste(\"posterior density of\",i))\n      }\n    }\n  }\n}\n\n\n# 2. plot the posterior estimated distribution of the fraction, marked with mean and HPD intervals you choose\n#' plot the posterior distribution of Fraction estimate\n#' \n#' display the histogram of posterior distribution of the fraction of aneuploidy cells, with mean and HPD (highest posterior density) intervals indicated on the plot\n#' \n#' @param object A MadSeqOutput object, which is produced by one of the runModel functions\n#' @param prob A numeric number in the interval(0,1) giving the probability content of the intervals\n#' @export\n#' @seealso \\code{\\link{plotPosterior}} \\code{\\link{plotMixture}}\nplotFraction = function(object,prob=0.95){\n  f = object$posterior[,\"f\"]\n  f_density = density(f)\n  y_max = max(hist(f,breaks=40,plot=FALSE)$density)\n  f_mean = signif(mean(f),2)\n  f_HDI = signif(HDIofMCMC(f,credMass = prob),2)\n  hist(f,prob=TRUE,breaks=40,xlab=\"\",ylab=\"\",main=\"posterior estimate of the fraction\",col=rgb(0,1,0,0.2),mgp=c(2,1,0),ylim=c(0,1.1*y_max),xlim=c(min(f),max(f)))\n  lines(f_density,col=\"black\",lty=2,lwd=3)\n  lines(x=c(f_mean,f_mean),y=c(0,1.01*y_max),col=\"red\",lwd=3)\n  text((max(f)+min(f))/2,1.03*y_max,paste(\"mean =\",as.character(f_mean)),cex=1.1)\n  lines(x=c(f_HDI[1],f_HDI[1]),y=c(0,0.25*y_max),col=\"red\",lwd=3)\n  lines(x=c(f_HDI[2],f_HDI[2]),y=c(0,0.25*y_max),col=\"red\",lwd=3)\n  text((max(f)+min(f))/2,1.09*y_max,paste(as.character(100*prob),\"% HPD = [\",as.character(f_HDI[1]),\",\",as.character(f_HDI[2]),\"]\",sep=\"\"),cex=1)\n}\n\n\n# 3. plot the estimated mixture posterior distribution \n#' plot the posterior estimates of mixture disbribution\n#' \n#' display the posterior mixture disbribution of alternative allele frequencies, indicating the mean of each mixture\n#' @param object A MadSeqOutput object, which is produced by one of the runModel functions\n#' @param labels logical; if TRUE, will label each mixture and give the mean value on the plot\n#' @export\n#' @seealso  \\code{\\link{plotPosterior}} \\code{\\link{plotFraction}}\nplotMixture = function(object,labels=TRUE){\n  data = object$posterior\n  data_variables = colnames(data)\n  data_median = apply(data,2,median)\n  \n  # check if the output is from one mixture model\n  if(is.element(\"mu\",data_variables)){\n    a = data_median[\"mu\"]*data_median[\"kappa\"]\n    b = (1-data_median[\"mu\"])*data_median[\"kappa\"]\n    y_max = max(dbeta(seq(0,1,0.01),a,b))\n    mu = signif(a/(a+b),2)\n    curve(0.99*dbeta(x,a,b),col=\"blue\",lwd=3,xlab=\"alternative allele frequency\",ylab=\"density\",main=\"posterior distribution of mixtures\",mgp=c(2,1,0),ylim=c(0,1.1*y_max),bty=\"l\")\n    curve(0.01*dbeta(x,1,1),col=\"grey4\",lwd=2,lty=2,add=TRUE)\n    if(labels==TRUE){\n      text(x= mu,1.05*y_max,paste(\"m =\",as.character(mu)))\n    }\n  }\n  \n  # check if the output is from four mixture model\n  else if(is.element(\"mu[3]\",data_variables)){\n    a1 = data_median[\"mu[1]\"]*data_median[\"kappa\"]\n    b1 = (1-data_median[\"mu[1]\"])*data_median[\"kappa\"]\n    a2 = data_median[\"mu[2]\"]*data_median[\"kappa\"]\n    b2 = (1-data_median[\"mu[2]\"])*data_median[\"kappa\"]\n    a3 = data_median[\"mu[3]\"]*data_median[\"kappa\"]\n    b3 = (1-data_median[\"mu[3]\"])*data_median[\"kappa\"]\n    a4 = data_median[\"mu[4]\"]*data_median[\"kappa\"]\n    b4 = (1-data_median[\"mu[4]\"])*data_median[\"kappa\"]\n    a5 = 1\n    b5 = 1\n    p1 = data_median[\"p[1]\"]\n    p2 = data_median[\"p[2]\"]\n    p3 = data_median[\"p[3]\"]\n    p4 = data_median[\"p[4]\"]\n    p5 = 0.01\n    \n    m1 = signif(a1/(a1+b1),2)\n    m2 = signif(a2/(a2+b2),2)\n    m3 = signif(a3/(a3+b3),2)\n    m4 = signif(a4/(a4+b4),2)\n    \n    y_max = max(c(p1*dbeta(seq(0,1,0.01),a1,b1),p2*dbeta(seq(0,1,0.01),a2,b2),p3*dbeta(seq(0,1,0.01),a3,b3),p4*dbeta(seq(0,1,0.01),a4,b4),p5*dbeta(seq(0,1,0.01),a5,b5)))\n    \n    curve(p1*dbeta(x,a1,b1),col=\"blue\",lwd=3,xlab=\"alternative allele frequency\",ylab=\"density\",main=\"posterior distribution of mixtures\",mgp=c(2,1,0),xlim=c(0,1),bty=\"l\",ylim=c(0,1.25*y_max))\n    curve(p2*dbeta(x,a2,b2),col=\"blue\",lwd=3,add=TRUE)\n    curve(p3*dbeta(x,a3,b3),col=\"green4\",lwd=3,add=TRUE)\n    curve(p4*dbeta(x,a4,b4),col=\"green4\",lwd=3,add=TRUE)\n    curve(p5*dbeta(x,a5,b5),col=\"grey4\",lwd=2,add=TRUE,lty=2)\n    \n    if(labels==TRUE){\n      text(m1,1.05*max(p1*dbeta(seq(0,1,0.01),a1,b1)),paste(\"m1 =\",as.character(m1)))\n      text(m2,1.05*max(p2*dbeta(seq(0,1,0.01),a2,b2)),paste(\"m2 =\",as.character(m2)))\n      text(m3,1.25*max(p3*dbeta(seq(0,1,0.01),a3,b3)),paste(\"m3 =\",as.character(m3)))\n      text(m4,1.25*max(p4*dbeta(seq(0,1,0.01),a4,b4)),paste(\"m4 =\",as.character(m4)))\n    }\n  }\n  \n  # then plot two mixtures\n  else{\n    a1 = data_median[\"mu[1]\"]*data_median[\"kappa\"]\n    b1 = (1-data_median[\"mu[1]\"])*data_median[\"kappa\"]\n    a2 = data_median[\"mu[2]\"]*data_median[\"kappa\"]\n    b2 = (1-data_median[\"mu[2]\"])*data_median[\"kappa\"]\n    a3 = 1\n    b3 = 1\n    \n    p1 = 0.495\n    p2 = 0.495\n    p3 = 0.01\n    \n    m1 = signif(a1/(a1+b1),2)\n    m2 = signif(a2/(a2+b2),2)\n    \n    y_max = max(c(p1*dbeta(seq(0,1,0.01),a1,b1),p2*dbeta(seq(0,1,0.01),a2,b2)))\n    \n    curve(p1*dbeta(x,a1,b1),col=\"blue\",lwd=3,xlab=\"alternative allele frequency\",ylab=\"density\",main=\"posterior distribution of mixtures\",mgp=c(2,1,0),xlim=c(0,1),bty=\"l\",ylim=c(0,1.1*y_max))\n    curve(p2*dbeta(x,a2,b2),col=\"blue\",lwd=3,add=TRUE)\n    curve(p3*dbeta(x,a3,b3),col=\"grey4\",lwd=2,add=TRUE,lty=2)\n    \n    if(labels==TRUE){\n      text(m1+0.1,y_max,paste(\"m1 =\",as.character(m1)))\n      text(m2-0.1,y_max,paste(\"m2 =\",as.character(m2)))\n    }\n  }\n}\n\n#------------------------MADSEQOUTPUT OBJECT--------------------------\n#-----------------------Constructor--------------------\n# constructor function for the class \"MadSeqOutput\"\n#' Produce Object of MadSeqOutput class, which is the output from runModel functions\n#' \n#' The function MadSeqOutput is used to represent the output from runModel functions. A MadSeqOutput object is a list with two components: \n#' 1. posterior: the posterior estimation from the MCMC run of the model. 2. BIC: the Bayesian Information Criteria for current model.\n#' \n#' @param x A MadSeqOutput object\n#' @return An object of class MadSeqOutput. \n#' @return The \\code{MadSeqOutput} class has its own \\code{print} method\n#' @export\nMadSeqOutput = function(x){\n  # check if x is a list\n  if(is.list(x)==FALSE) stop(\"X must be a list\")\n  # check if x consists of two components\n  if(length(x)!=2) stop(\"X must have two components\")\n  # check the elements of X\n  if(!is.matrix(x$posterior)) stop(\"posterior must contain a matrix\")\n  if(!is.numeric(x$BIC)) stop(\"BIC must be numeric\")\n  class(x) = \"MadSeqOutput\"\n  return(x)\n}\n\n#' \n#' @rdname MadSeqOutput\nas.MadSeqOutput = function(x){\n  x = MadSeqOutput(x)\n  return(x)\n}\n\n#' @rdname MadSeqOutput\nis.MadSeqOutput = function(x){\n  if(class(x)==\"MadSeqOutput\") return(TRUE)\n  else return(FALSE)\n}\n\n#-------------------------Method-----------------------\n# 1. print MadSeqOutput object. Print out the mean and sd of posterior distribution and the BIC value\n#' print method for MadSeqOutput object\n#'\n#' print an object of MadSeqOutput class. It will print out the mean and 95% Highest density inverval of the posterior distribution estimated by the runModels function.\n#' @param x An object of MadSeqOutput class\n#' @param ... further arguments passed to or from other methods.\n#' @seealso \\code{\\link{runModelOne}} \\code{\\link{runModelMonosomy}} \\code{\\link{runModelTrisomy}} \\code{\\link{runModelFour}} \\code{\\link{MadSeqOutput}} \n#' @method print MadSeqOutput\n#' @export \nprint.MadSeqOutput = function(x,...){\n  mat = x$posterior\n  mat = mat[,-match(c(\"p_cov\",\"r_cov\"),colnames(mat))]\n  BIC = x$BIC\n  cat(\"Posterior Distribution for Parameters\\n\")\n  post_mean = signif(apply(mat,2,mean),3)\n  post_HDI = signif(apply(mat,2,HDIofMCMC),3)\n  HDI = paste(\"[\",signif(post_HDI[1,],3),\", \",signif(post_HDI[2,],3),\"]\",sep=\"\")\n  post = data.frame(post_mean,HDI)\n  names(post) = c(\"mean\",\"95% HDI\")\n  print(post)\n  cat(\"\\n\")\n  cat(\"BIC\\n\")\n  print(unname(BIC))  \n}\n\n# 2. summary. Summarize the posterior distribution as a data.frame\n#' summary statistics for MadSeqOutput object\n#'\n#' summary.MadSeqOutput produce the summary statistics for the posterior distribution produced by runModels function. \n#' @param object An object of MadSeqOutput class\n#' @param ... further arguments passed to or from other methods.\n#' @seealso \\code{\\link{runModelOne}} \\code{\\link{runModelMonosomy}} \\code{\\link{runModelTrisomy}} \\code{\\link{runModelFour}} \\code{\\link{MadSeqOutput}}\n#' @method summary MadSeqOutput\n#' @export \nsummary.MadSeqOutput = function(object,...){\n  mat = as.data.frame(object$posterior)\n  print(summary(mat))\n}\n\n\n",
    "created" : 1438180534094.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2683422820",
    "id" : "6C3025DA",
    "lastKnownWriteTime" : 1438182375,
    "path" : "~/Project/Aneuploidy/MADSEQ/R/Function.R",
    "project_path" : "R/Function.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}